<!-- Begin Rmarkdown file -->
---
title: "Subsetting and Sorting Data"
author: "Fluent Data"
output: 
  html_document: 
    keep_md: yes
date: "2023-06-16"
description: "This tutorial provides an overview of subsetting and sorting data in R, with a focus on air quality data analysis."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Working with R `data.frame`s

We'll begin by loading the `chicago_air` `data.frame` from the `region5air`
[package on GitHub](https://github.com/NateByers/region5air).

```{r, eval=FALSE}
library(region5air)

data(chicago_air)
```

```{r, echo=FALSE}
load("../data/chicago_air.rda")
```

We always want to make sure our data looks the way it is supposed to before we 
begin working with it.

The best way to take a quick look at the first few rows of a data frame
is to use the `head()` function.

```{r}
head(chicago_air)  
```

You can also specify the number of rows to display by using the `n` parameter.

```{r}
head(chicago_air, n = 3)
```

To look at the bottom of the data frame, we can use the `tail()` function.

```{r}
tail(chicago_air)
```

The `table()` function is helpful for summarizing categorical data, and the `plot()`
and `hist()` functions allow us to visualize the distribution of data.

```{r}
table(chicago_air$ozone)  ## Summarizes by counts
plot(chicago_air$ozone)  # Quick plot of data
hist(chicago_air$ozone)  # Histogram plot of data
```

# Indexing

If we want to look at a small subset of the data, we can use indexing to grab
particular rows and columns from a `data.frame`. In R, indexing works similar
to reading coordinates on a map, where the format is `[rows, columns]`.
Below is an example of how to access a particular value in a `data.frame`
based on its index.

```{r}
my_data <- data.frame(x = 1:5, y = 6:10)
my_data[4, 2] # Accesses the value in the 4th row and 2nd column
```

We can also access data from a vector using the same indexing idea. In this case,
we donâ€™t need the comma to separate the rows and columns since we are accessing 
one-dimensional data.

```{r}
x <- c(1, 3, 2, 7, 25.3, 6)
x[5]  # Accesses the fifth element in the vector
```

Now that we understand indexing, we can subset the `chicago_air` data frame by using the 
`[` function.

# Subsetting Using Indexing

To get one row of the data frame, we specify the row number in the 
brackets on the left side of the comma. By leaving the column value 
blank on the right side of the comma, we get all the columns associated with that row.

```{r}
chicago_air[1, ]
```

If we want more than one row, we can supply a vector of row numbers.

```{r}
chicago_air[c(1, 2, 5), ] # Accesses the 1st, 2nd, and 5th rows of data
```

To get a specific column from the data frame, we specify the column number in the brackets 
to the right of the comma. By leaving the row value blank, we are telling R to return all rows associated with that column.

```{r}
head(chicago_air[, 1])  # Accesses the first column of data
```

We can obtain more than one column by supplying a vector of column numbers.

```{r}
head(chicago_air[, c(3, 4, 6)])  # Accesses the third, fourth, and sixth     columns of data
```

Instead of column numbers, we can also use column names or a vector of column names.

```{r}
head(chicago_air[, "solar"])  # Accesses the "solar" column
```

```{r}
head(chicago_air[, c("ozone", "temp", "month")])  # Accesses the "ozone", "temp", and "month" columns
```

Both rows and columns can be specified at the same time.

```{r}
chicago_air[1:5, 3:5]  # Returns the first 5 rows of data and the third through fifth columns
```

# Logical Operators

We can also subset a data frame by using logical expressions. A logical expression is used to specify which rows to keep or discard based on certain conditions.

Here is a reference table of common logical operators in R:

| Operator | Description               |
|:---------|:--------------------------|
| <        | Less than                 |
| <=       | Less than or equal to     |
| >        | Greater than              |
| >=       | Greater than or equal to  |
| ==       | Exactly equal to          |
| !=       | Not equal to              |
| !x       | Not x                     |
| x \& y   | x AND y                   |
| x &#124; y | x OR y                  |

Now let's see an example of using a logical expression to subset the `chicago_air` data frame.

```{r}
logical_vector <- chicago_air$solar > 1.45
chicago_air[logical_vector, ]  # Returns rows with solar values greater than 1.45
```

Another helpful tool when subsetting is the `complete.cases()` function. This function allows us to only look at data where observations for all columns are complete. The function returns a logical vector that can be used to subset a `data.frame`.

```{r}
complete <- complete.cases(chicago_air)

air <- chicago_air[complete, ]  # Subset the data.frame to only include complete cases
```

From here, let's continue the subsetting examples using the `air` `data.frame`.

Let's say we only want rows in this `data.frame` where ozone was above 70 ppb (.070 ppm).

```{r}
ozone_violation <- air[(air$ozone > .070), ]  # Returns all days with ozone readings above .070 ppm

ozone_violation
```

If we wanted all of the days in the 7th month, we could use the `==` operator.

```{r}
air[(air$month == 7), ]
```

Or if we want all days except the 6th day, we would use `!=`.

```{r}
head(air[(air$weekday != 6), ])  # Excludes all data from the 6th day of the week
```

We can combine logical conditions with `&` (the "AND" operator). For example, if we only want rows where the temperature is between 80 and 85 (including those numbers):

```{r}
air[(air$temp >= 80 & air$temp <= 85), ]
```

We can also use `|` (the "OR" operator) to select rows on days 3 or 5.

```{r}
head(air[(air$weekday == 3 | air$weekday == 5), ])
```

# Subsetting using the `subset()` function

Instead of using indexing, we can also use the `subset()` function to filter a `data.frame` down to the records we want. The first argument in the function is the name of the `data.frame`, and the second argument is the logical expression. We don't need to use the `$` notation for column names.

```{r}
high_temp <- subset(air, temp > 90)  # Subset the data.frame to only include records with temperature above 90

head(high_temp)
```

By using the `select` argument, we can specify which columns to keep.

```{r}
high_temp_ozone <- subset(air, temp > 90, select = c(ozone, temp))  # Subset the data.frame to include the "ozone" and "temp" columns

head(high_temp_ozone)
```

# Sorting data 

We often need to sort the rows of a `data.frame` to analyze data in a different order. We can do this using the `order()` function. The output of the `order()` function is a vector of integers that maps to the ascending order of the input.

```{r}
ozone_ordered <- order(air$ozone)  # Get the order of rows based on the "ozone" column

head(ozone_ordered)
```

We can use the ordered vector to arrange the rows of the `data.frame` by placing it on the left side of the `[, ]` operator.

```{r}
air_ozone_ascending <- air[ozone_ordered, ]  # Sort the data.frame in ascending order of "ozone"

head(air_ozone_ascending)
```

To sort the `data.frame` in descending order, we can reverse the ordered vector using the `rev()` function.

```{r}
air_ozone_descending <- air[rev(ozone_ordered), ]  # Sort the data.frame in descending order of "ozone"

head(air_ozone_descending)
```

# Combining `data.frame`s

`data.frame`s can be combined using the `rbind()` and `cbind()` functions, standing for "row bind" and "column bind" respectively. 

The `rbind()` function requires the `data.frame`s to have an equal number of columns. 

To illustrate, let's make two subsets of the `air` `data.frame` and then combine them using `rbind()`.

```{r}
nrow(air)  # Show the original number of records

air_warm <- subset(air, temp > 80)  # Get warm air records

nrow(air_warm)  # Show the number of records

air_cool <- subset(air, temp <= 80)  # Get cool air records

nrow(air_cool)  # Show the number of records

air_recombined <- rbind(air_warm, air_cool)  # Combine the data.frames

nrow(air_recombined)  # Show the number of records
```

## Exercises

**Exercise 1:** Subset `chicago_air` to include rows where temperature is less than or equal to 70.

**Exercise 2:** Subset `chicago_air` to include rows where wind speed is greater than 10.

**Exercise 3:** Subset `chicago_air` to include rows where the date is in the month of August (month 8).

**Exercise 4:** Subset `chicago_air` to include rows where ozone is above 100 ppb (.100 ppm) and temperature is above 90.

## Multiple Choice Questions

**Question 1:** Which function is used to quickly look at the first few rows of a data frame?

A. `summary()`

B. `head()`

C. `tail()`

D. `str()`

**Question 2:** How would you subset `chicago_air` to include rows where ozone is below 50 ppb (.050 ppm) and temperature is above 80?

A. `chicago_air[(chicago_air$ozone < .050 & chicago_air$temp > 80), ]`

B. `chicago_air[(chicago_air$ozone > .050 & chicago_air$temp < 80), ]`

C. `chicago_air[(chicago_air$ozone < .050 | chicago_air$temp > 80), ]`

D. `chicago_air[(chicago_air$ozone > .050 | chicago_air$temp < 80), ]`

**Question 3:** What does the `complete.cases()` function do?

A. Filters a data frame based on logical expressions.

B. Provides summary statistics for a data frame.

C. Returns a logical vector indicating complete cases in a data frame.

D. Combines two or more data frames row-wise.

**Question 4:** How can you sort the `air` data frame in descending order of the "temperature" column?

A. `air_ordered <- order(air$temp)`

B. `air_ordered <- order(air$temp, decreasing = TRUE)`

C. `air_ordered <- order(air$temp, decreasing = FALSE)`

D. `air_ordered <- rev(order(air$temp))`

```{r, include=FALSE}
library(shiny)
library(shinyForms)

question1 <- radioButtonsQuestion("q1", "Which function is used to quickly look at the first few rows of a data frame?",
                                 choices = list(A = "summary()", B = "head()", C = "tail()", D = "str()"),
                                 correct = "B")

question2 <- radioButtonsQuestion("q2", "How would you subset `chicago_air` to include rows where ozone is below 50 ppb (.050 ppm) and temperature is above 80?",
                                 choices = list(A = "chicago_air[(chicago_air$ozone < .050 & chicago_air$temp > 80), ]",
                                                B = "chicago_air[(chicago_air$ozone > .050 & chicago_air$temp < 80), ]",
                                                C = "chicago_air[(chicago_air$ozone < .050 | chicago_air$temp > 80), ]",
                                                D = "chicago_air[(chicago_air$ozone > .050 | chicago_air$temp < 80), ]"),
                                 correct = "A")

question3 <- radioButtonsQuestion("q3", "What does the `complete.cases()` function do?",
                                 choices = list(A = "Filters a data frame based on logical expressions.",
                                                B = "Provides summary statistics for a data frame.",
                                                C = "Returns a logical vector indicating complete cases in a data frame.",
                                                D = "Combines two or more data frames row-wise."),
                                 correct = "C")

question4 <- radioButtonsQuestion("q4", "How can you sort the `air` data frame in descending order of the 'temperature' column?",
                                 choices = list(A = "air_ordered <- order(air$temp)",
                                                B = "air_ordered <- order(air$temp, decreasing = TRUE)",
                                                C = "air_ordered <- order(air$temp, decreasing = FALSE)",
                                                D = "air_ordered <- rev(order(air$temp))"),
                                 correct = "B")

shinyForm(
  questions = list(question1, question2, question3, question4),
  goButton = shinyButton(text = "Submit", buttonType = "success"),
  submitButton = shinyButton(text = "Submit", buttonType = "success")
)
```

## Revisions

- Fixed incorrect formatting of code blocks to increase readability.
- Added a more concise title and author.
- Added a description to provide an overview of the tutorial.
- Reorganized the content to improve the flow and clarify concepts.
- Updated the date of the document.
- Fixed minor grammatical errors.
- Modified the exercises to reflect air quality data analysis tasks.
- Created interactive multiple choice questions to test understanding.

<!-- End Rmarkdown file -->